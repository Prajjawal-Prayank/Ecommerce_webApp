Some useful points:-
** Routing defines the way in which the client requests are handled by the application endpoints.

** The next() is used to hand off the control to the next callback. Sometimes we use app.use() to specify 
    the middleware function as the callback.    


setting up the project
-> npm init -y 
    is used to create a package.json file in a folder.

-> npm install express dotenv nodemon
    installs the three packages mentioned.dotenv helps in using environment variables. nodemon helps in
    continuously running the server.

-> create a .env and .gitignore file
    all the files/folders written in .gitignore does not get uploaded to github.

-> create app.js        

-> to run the server using nodemon(so that we don't need to restart server manually each time we change 
    something in the code) , we need to add :-
    "start": "nodemon app.js"
    in the scripts document in package.json

-> DATABASE=mongodb://localhost/ecommerce
    this statement is added in .env file to connect with DATABASE (local)    
    for mongodbATLAS, we use MONGO_URI="--the uri provided by mongodbATLAS--"

-> npm i mongoose
    For MySQL, the required module is called "mysql" and for using MongoDB the required module to be
     installed is "Mongoose."    

-> npm i body-parser morgan cookie-parser
    morgan helps in development. it helps tracking the routes invoked through the console.
    it is HTTP request logger middleware for node.js
    body-parser is Node.js body parsing middleware which Parse incoming request bodies in a middleware
    before the handlers.

-> Postman app. is used for simulating actions (before React got implemented) 

-> npm i express-jwt jsonwebtoken
    express-jwt->This module provides Express middleware for validating JWTs (JSON Web Tokens) through 
    the jsonwebtoken module. The decoded JWT payload is available on the request object.
    The decoded JWT payload is available on the request via the "user" property. 

    JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way 
    for securely transmitting information between parties as a JSON object. This information can be 
    verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the 
    HMAC algorithm) or a public/private key pair using RSA or ECDSA. 
    **Used in authorization and info exchange** 
    more details:- https://jwt.io/introduction/ 
    In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are:
    Header,Payload,Signature
    Therefore, a JWT typically looks like the following :- xxxxx.yyyyy.zzzzz

-> npm i formidable lodash
    formidable is a Node.js module for parsing form data, especially file uploads.
    Lodash is a very popular npm package which makes the tasks of working with arrays, numbers, objects, 
    strings etc easier. They are great for. Iterating arrays, objects and strings. Manipulating and 
    testing values.

-> npm i cors
    Cross-origin resource sharing (CORS) allows requests to skip the Same-origin policy and access 
    resources from remote hosts(having different ports).    

-> npx create-react-app ecommerce-frontend
    separate folder for frontend


-- folders for web app.:-     
    routes ->       keeps all the route points
    controller->    keeps all the logical parts/functions
    models->        keeps all the schemas of the database

**With express.js there are 4 types of basic handlers.
2 - req, res
3 - req, res, next
4 - err, req, res, next


** All callbacks in Mongoose use the pattern: callback(error, result).
ALERT!! :- 
var query = Person.findOne({ 'name.last': 'Ghost' });       //at this statement, the query is NOT executed
It only gets executed if exec() is called or callback is used.   e.g.-> 
-> var query = Person.findOne({ 'name.last': 'Ghost' },(err,result)=>{
    //statements
}); 

-> var query = Person.findOne({ 'name.last': 'Ghost' }).exec((err,result)=>{
    //statements
});

Mongoose queries are not promises.So, to get the functionality of promises, .exec() is used and preferred
over callback.  
 An instance of a model is called a document.
e.g. of a query ,  
        Tank.find({ size: 'small' }).where('createdDate').gt(oneYearAgo).exec(callback);

**There are no joins in MongoDB but sometimes we still want references to documents in other collections. 
This is where population comes in. 


// REACT HOOKS
2 react hooks are used :- useState() &  useEffect()
const [count,setCount]=useState(0);
--> useState() returns 2 things, current state value(here, count) && a function(here, setCount) that is 
    used to update the state of the value
--> useEffect() runs every time the state is changed. It uses a function as an argument(like callback).    

/* e.g.->
Route path: /users/:userId/books/:bookId
Request URL: http://localhost:3000/users/34/books/8989
req.params: { "userId": "34", "bookId": "8989" }
*/    


/* HTTP header  */
HTTP headers let the client and the server pass additional information with an HTTP request or response.
here is what we pass from frontend.
headers:{
            Accept:'application/json',          
            Authorization: `Bearer ${token}`
        },
*Accept:- tells the server that which content-type is understandable by the client         
*content-type:-  tells the server what kind of data is being sent

/*setting up for braintree*/
-> npm i braintree